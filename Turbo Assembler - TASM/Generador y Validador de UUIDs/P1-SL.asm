.MODEL SMALL
.DATA 
	TEXTO_A DB 13, 10, 'INGRESE 1 PARA GENERAR UUID $'
	TEXTO_B DB 13, 10, 'INGRESE 2 PARA VALIDAR UUID $'
	TEXTO_C DB 13, 10, 'CUALQUIER OTRO INGRESO = SALIR $'
	TEXTO_D DB 'INGRESE SU UUID $'
	TEXTO_E DB 13, 10, 'DEBE INGRESAR UN NUMERO ENTRE 0-9 O UNA LETRA ENTRE A-F $'
	TEXTO_F DB 13, 10, 'DEBE INGRESAR EL NUMERO 1 $'
	TEXTO_G DB 13, 10, 'DEBE INGRESAR UN 8, 9, A O B $'
	TEXTO_H DB 13, 10, 'DEBE INGRESAR UN GUION (-) $'
	TEXTO_I DB 13, 10, 'UUID CORRECTO $'
	TEXTO_J DB 'UUID: $'
	TEXTO_K DB 'CUANTOS UUID DESEA GENERAR?  $'
	TEXTO_FIN DB 13, 10, '--- FIN --- $'
	
	CARACTER DB ?
	
	REPETICIONES DW ?
	REPETICIONES2 DB ?
	RANDOM DB 0
	TMP_CX DW ?
	TMP_CX2 DW ?
	AUXILIAR_TICKS DB ?
	
.STACK
.CODE
MAIN:
	XOR AX, AX				; SE LIMPIAN TODAS LA VARIALBES DEL SISTEMA
	XOR BX, BX
	XOR CX, CX
	XOR DX, DX
	
	MOV AX, @DATA			; INICIALIZACIÓN
	MOV DS, AX
	
	LEA DX, TEXTO_A			; ESCRIBIR INGRESE 1 PARA GENERAR UUID
	MOV AH, 09H
	INT 21H
	CALL LIMPIAR
	LEA DX, TEXTO_B			; ESCRIBIR INGRESE 2 PARA GENERAR UUID
	MOV AH, 09H
	INT 21H
	CALL LIMPIAR	
	LEA DX, TEXTO_C			; ESCRIBIR INGRESE 3 PARA SALIR
	MOV AH, 09H
	INT 21H
	CALL SALTO_LINEA
	
	CALL LEER				; LEER OPCIÓN
	CALL SALTO_LINEA
	CALL LIMPIAR
	
	CMP CARACTER, 31H		; COMPARA IF CARACTER == 1
	JZ PARTE_UNO
	
	CMP CARACTER, 32H		; COMPARA IF CARACTER == 2
	JZ PARTE_DOS
	
FINALIZAR:			
	CALL LIMPIAR
	LEA DX, TEXTO_FIN		; ESCRIBIR --- FIN ---
	MOV AH, 09H
	INT 21H
	
	MOV AH, 4CH				; FINALIZACIÓN
	INT 21H

PARTE_DOS:
	CALL LIMPIAR
	LEA DX, TEXTO_D			; ESCRIBIR INGRESE SU UUID
	MOV AH, 09H
	INT 21H
	
	MOV CX, 08H				; CICLO DE 8 VUELTAS
	CICLO_AF_UNO:
		CALL COMPARAR_AF
	LOOP CICLO_AF_UNO
	
	CALL COMPARAR_GUION
	
	XOR CX, CX
	MOV CX, 04H				; CICLO DE 4 VUELTAS
	CICLO_AF_DOS:
		CALL COMPARAR_AF
	LOOP CICLO_AF_DOS
	
	CALL COMPARAR_GUION
	CALL COMPARAR_UNO
	
	XOR CX, CX
	MOV CX, 03H				; CICLO DE 3 VUELTAS
	CICLO_AF_TRES:
		CALL COMPARAR_AF
	LOOP CICLO_AF_TRES
	
	CALL COMPARAR_GUION
	CALL COMPARAR_AB
	
	XOR CX, CX
	MOV CX, 03H				; CICLO DE 3 VUELTAS
	CICLO_AF_CUATRO:
		CALL COMPARAR_AF
	LOOP CICLO_AF_CUATRO
	
	CALL COMPARAR_GUION
	
	XOR CX, CX
	MOV CX, 12D				; CICLO DE 12 VUELTAS
	CICLO_AF_CINCO:
		CALL COMPARAR_AF
	LOOP CICLO_AF_CINCO
	
	CALL LIMPIAR
	LEA DX, TEXTO_I			; ESCRIBIR UUID CORRECTO
	MOV AH, 09H
	INT 21H
	
	JMP MAIN

PARTE_UNO:
	CALL LIMPIAR
	LEA DX, TEXTO_K			; ESCRIBIR CUANTOS UUID DESEA GENERAR?
	MOV AH, 09H
	INT 21H
	
	CALL LIMPIAR
	MOV AH, 01H				; LEE CARACTER INGRESADO
	INT 21H
	SUB AL, 30H
	MOV REPETICIONES2, AL	; SE GUARDA LO INGRESADO EN REPETICIONES
	CALL SALTO_LINEA
	CALL LIMPIAR
	
	XOR CX, CX
	MOV CL, REPETICIONES2
	CICLO_REPE:
		CALL GENERAR
		CALL SALTO_LINEA
	LOOP CICLO_REPE
	
	CALL LIMPIAR
	JMP MAIN
	
; ------------------------------- PROCEDIMIENTOS -------------------------------
LEER PROC NEAR
	CALL LIMPIAR
	MOV AH, 01H				; LEE CARACTER INGRESADO
	INT 21H
	MOV CARACTER, AL		; SE GUARDA LO INGRESADO EN CARACTER AH
	;INT 21H
RET
LEER ENDP

LIMPIAR PROC NEAR
	XOR DX, DX				; SE LIMPIAN LOS REGISTROS
	XOR AX, AX
RET
LIMPIAR ENDP

SALTO_LINEA PROC NEAR
	MOV AH, 02H
	MOV DL, 0AH 			; SALTO DE LINEA
	INT 21H
	MOV AH, 02H
	MOV DL, 0DH				; RETORNO DE CARRO
	INT 21H
RET
SALTO_LINEA ENDP

; ---------------------------- ETIQUETAS AUXILIARES ----------------------------
FINALIZAR_AUX:
	JMP FINALIZAR

; -------------------------- PROCEDIMIENTOS PARTE DOS --------------------------
COMPARAR_AF PROC NEAR
	; DES < ORI ZF = 0 CF = 1			JZ - ZF = 1		
	; DES > ORI ZF = 0 CF = 0			JC - CF = 1		JNS - CF = 0
	; DES = ORI ZF = 1 CF = 0			JNZ - ZF = 0	JAE - CF = 0
	CALL LIMPIAR
	CALL LEER
	CMP CARACTER, 67H		; 67H = g
	JNS MAL_AF 	
	
	CMP CARACTER, 61H		; 61H = a
	JC MENOR_61H
	JMP RETORNAR
	
	MENOR_61H:				; CARACTER < g && >= a
		CMP CARACTER, 47H	; 47H = G
		JNS MAL_AF
		CMP CARACTER, 41H	; 41H = A
		JC MENOR_41H
		JMP RETORNAR
	MENOR_41H:
		CMP CARACTER, 3AH	; 3AH = :
		JNS MAL_AF
		CMP CARACTER, 30H	; 30H = 0
		JC MAL_AF
		JMP RETORNAR
	MAL_AF:
		LEA DX, TEXTO_E		; ESCRIBIR DEBE INGRESAR UN NUMERO ENTRE 0-9 O UNA LETRA ENTRE A-F 
		MOV AH, 09H
		INT 21H
		JMP FINALIZAR_AUX
	RETORNAR:
RET
COMPARAR_AF ENDP

COMPARAR_AB PROC NEAR
	CALL LIMPIAR
	CALL LEER
	CMP CARACTER, 38H		; CARACTER == 8
	JZ RETORNAR_AB
	
	CMP CARACTER, 39H		; CARACTER == 9
	JZ RETORNAR_AB
	
	CMP CARACTER, 41H 		; CARACTER == A
	JZ RETORNAR_AB
	
	CMP CARACTER, 42H		; CARACTER == B
	JZ RETORNAR_AB
	
	CMP CARACTER, 61H		; CARACTER == a
	JZ RETORNAR_AB
	
	CMP CARACTER, 62H		; CARACTER == b
	JZ RETORNAR_AB
	
	; SI LLEGA ACA ES POR QUE NO ES IGUAL A NINGUNA DE LA OPCIONES
	CALL LIMPIAR
	LEA DX, TEXTO_G			; ESCRIBIR DEBE INGRESAR UN GUION (-)
	MOV AH, 09H
	INT 21H
	JMP FINALIZAR_AUX
	
	RETORNAR_AB:
RET
COMPARAR_AB ENDP

COMPARAR_GUION PROC NEAR
	CALL LIMPIAR
	CALL LEER
	CMP CARACTER, 2DH
	JZ RETORNAR_G
	
	MAL_GUION:
		CALL LIMPIAR
		LEA DX, TEXTO_H		; ESCRIBIR DEBE INGRESAR UN GUION (-)
		MOV AH, 09H
		INT 21H
		JMP FINALIZAR_AUX
	RETORNAR_G:
RET
COMPARAR_GUION ENDP

COMPARAR_UNO PROC NEAR
	CALL LIMPIAR
	CALL LEER
	CMP CARACTER, 31H
	JZ RETORNAR_UNO
	
	MAL_UNO:
		CALL LIMPIAR
		LEA DX, TEXTO_F		; ESCRIBIR DEBE INGRESAR EL NUMERO 1
		MOV AH, 09H
		INT 21H
		JMP FINALIZAR_AUX
	RETORNAR_UNO:
RET
COMPARAR_UNO ENDP

; -------------------------- PROCEDIMIENTOS PARTE UNO --------------------------
GENERAR PROC NEAR
	MOV TMP_CX2, CX			; GUARDO LO QUE SE INGRESO EN REPETICIONES2
	
	XOR CX, CX
	MOV CX, 8D				; CICLO DE 8 VUELTAS
	CICLO_RND:
		CALL RND
	LOOP CICLO_RND
	
	MOV DL, 2DH				; IMPRIMER UN GUION
	MOV AH, 02H
	INT 21H
	
	XOR CX, CX
	MOV CX, 4D				; CICLO DE 4 VUELTAS
	CICLO_RND2:
		CALL RND
	LOOP CICLO_RND2
	
	MOV DL, 2DH				; IMPRIME UN GUION
	MOV AH, 02H
	INT 21H
	
	MOV DL, 31H				; IMPRIME UN 1
	MOV AH, 02H
	INT 21H
	
	XOR CX, CX
	MOV CX, 3D				; CICLO DE 3 VUELTAS
	CICLO_RND3:
		CALL RND
	LOOP CICLO_RND3
	
	MOV DL, 2DH				; IMPRIMER UN GUION
	MOV AH, 02H
	INT 21H
	
	CALL RND2				; IMPRIMER 8, 9, A o B
	
	XOR CX, CX
	MOV CX, 3D				; CICLO DE 3 VUELTAS
	CICLO_RND4:
		CALL RND
	LOOP CICLO_RND4
	
	MOV DL, 2DH				; IMPRIMER UN GUION
	MOV AH, 02H
	INT 21H
	
	XOR CX, CX
	MOV CX, 12D				; CICLO DE 12 VUELTAS
	CICLO_RND5:
		CALL RND
	LOOP CICLO_RND5
	
	MOV CX, TMP_CX2
	MOV TMP_CX2, 0H
	
RET
GENERAR ENDP

RND PROC NEAR
	; PARA LA OBTENCIÓN DEL NUMERO ALEATORIO SE HACE UNA SUMA CON TODOS LOS ELEMENTOS
	; DE LA FECHA Y HORA DEL SISTEMA, EL RESULTADO SE ALMACENA EN UNA VARIABLE
	; QUE LUEGO SE DIVIDE ENTRE 16 PARA OBTENER EL RESIDUO Y DEJARLO BASE HEXADECIMAL
	
	MOV RANDOM, 0H			; LIMPIEZA EN RANDOM PARA NO SOBRE ESCRIBIR DATOS
	XOR AX, AX
	MOV TMP_CX, CX			; SE GUARDA EL VALOR DE CX EN UNA VARIABLE AUXILIAR Y NO PERDER EL ORDEN DEL CICLO LUEGO
	
	MOV AH, 00H				; INTERRUPCIÓN PARA OBTENER EL TIEMPO DEL SISTEMA
	INT 1AH					; CX:DX CONTIENE EL NUMERO DE TICKS DESDE LA MEDIA NOCHE
	
	MOV AX, DX				
	XOR DX, DX
	CALL HASH
	MOV CX, 10H				; SE ALMACENA 10H EN CX PARA REALIZAR LA DIVISIÓN Y OBTENER UN NUMERO ENTRE [0-F]
	DIV CX
	MOV RANDOM, DL			; SE ALMACENA EL RESIDUO EN RANDOM
	XOR AX, AX
	
	MOV AUXILIAR_TICKS, DL	; SE ALMACENA EL VALOR DE RANDOM PARA SER UTILIZADO EN EL SIGUIENTE HASH
	
	CMP RANDOM, 9H			; SE EVALUA RANDOM != 9
	JLE NUMERO
	CMP RANDOM, 9H			; SE EVALUA RANDOM >= 9
	JG LETRA
	
	JMP RETORNAR_RND
	
	LETRA:
		ADD DL, 37H			; SE SUMA 65
		MOV AH, 02H			; SE IMPRIME EL CARACTER 
		INT 21H
		JMP RETORNAR_RND
	NUMERO:
		ADD DL, 30H			; SE SUMA 
		MOV AH, 02H			; SE IMPRIME EL CARACTER
		INT 21H
		JMP RETORNAR_RND
	RETORNAR_RND:
		MOV CX, TMP_CX
		MOV TMP_CX, 0H
RET
RND ENDP

RND2 PROC NEAR
	; PARA LA OBTENCIÓN DEL NUMERO ALEATORIO SE HACE UNA SUMA CON TODOS LOS ELEMENTOS
	; DE LA FECHA Y HORA DEL SISTEMA, EL RESULTADO SE ALMACENA EN UNA VARIABLE
	; QUE LUEGO SE DIVIDE ENTRE 16 PARA OBTENER EL RESIDUO Y DEJARLO BASE HEXADECIMAL
	
	MOV RANDOM, 0H			; LIMPIEZA EN RANDOM PARA NO SOBRE ESCRIBIR DATOS
	XOR AX, AX
	MOV TMP_CX, CX			; SE GUARDA EL VALOR DE CX EN UNA VARIABLE AUXILIAR Y NO PERDER EL ORDEN DEL CICLO LUEGO
	
	MOV AH, 00H				; INTERRUPCIÓN PARA OBTENER EL TIEMPO DEL SISTEMA
	INT 1AH					; CX:DX CONTIENE EL NUMERO DE TICKS DESDE LA MEDIA NOCHE
	
	MOV AX, DX				
	XOR DX, DX
	CALL HASH
	MOV CX, 10H				; SE ALMACENA 10H EN CX PARA REALIZAR LA DIVISIÓN Y OBTENER UN NUMERO ENTRE [0-F]
	DIV CX
	MOV RANDOM, DL			; SE ALMACENA EL RESIDUO EN RANDOM
	XOR AX, AX
	
	MOV AUXILIAR_TICKS, DL	; SE ALMACENA EL VALOR DE RANDOM PARA SER UTILIZADO EN EL SIGUIENTE HASH
	
	CMP RANDOM, 9H			; SE EVALUA RANDOM != 9
	JLE NUMERO2
	CMP RANDOM, 9H			; SE EVALUA RANDOM >= 9
	JG LETRA2
	
	JMP RETORNAR_RND2
	
	LETRA2:
		ADD DL, 37H			; SE SUMA 65
		CMP DL, 44H
		JC PRINT_A			; SI DL < D
		
		CMP DL, 44H
		JAE PRINT_B			; SI DL >= D
		
		PRINT_A:
			MOV DL, 41H
			MOV AH, 02H
			INT 21H
			JMP RETORNAR_RND2
		PRINT_B:
			MOV DL, 42H
			MOV AH, 02H
			INT 21H
			JMP RETORNAR_RND2
	NUMERO2:
		ADD DL, 30H			; SE SUMA

		CMP DL, 35H
		JC PRINT_1			; SI DL < 5
		
		CMP DL, 35H
		JAE PRINT_2			; SI DL >= 5
		
		PRINT_1:
			MOV DL, 31H
			MOV AH, 02H
			INT 21H
			JMP RETORNAR_RND2
		PRINT_2:
			MOV DL, 32H
			MOV AH, 02H
			INT 21H
			JMP RETORNAR_RND2
	RETORNAR_RND2:
		MOV CX, TMP_CX
		MOV TMP_CX, 0H
RET
RND2 ENDP

HASH PROC NEAR 				; MODIFICA EL VALOR DE AX ASI GENERA DIFERENTE NUMEROS RANDOM CON EL MISMO TICK
	MOV BL, AUXILIAR_TICKS
	ADD AX, BX
	MOV BX, 45H
	DIV BX
	MOV AL, DL
	XOR DX, DX	
RET
HASH ENDP

END